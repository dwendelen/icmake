includefile(release.yo)

htmlbodyopt(text)(#27408B)
htmlbodyopt(bgcolor)(#FFFAF0)
whenhtml(mailto(Frank B. Brokken: f.b.brokken@rug.nl))

DEFINEMACRO(sop)(3)(\
    it() bf(-ARG1) ARG2 nl()ARG3\
)

DEFINEMACRO(itt)(1)(\
    it()tt(ARG1)\
)

DEFINEMACRO(itb)(1)(\
    it()bf(ARG1)nl()\
)

DEFINEMACRO(icb)(0)(bf(icmbuild))
DEFINEMACRO(Icb)(0)(bf(Icmbuild))

DELETEMACRO(tt)
DEFINEMACRO(tt)(1)(em(ARG1))

COMMENT( man-request, section, date, distribution file, general name)
manpage(icmbuild)(1)(_CurYrs_)(icmake._CurVers_.tar.gz)
        (A generic program maintenance script)

COMMENT( man-request, larger title )
manpagename(icmbuild)(A generic, easy configurable, program maintenance script)

COMMENT( all other: add after () )
manpagesynopsis()
       icb() [-h] [-c] tt(args)

manpagedescription()

The icb() script is a generic script that can be used to do program
maintenance using bf(icmake)(1). 

Icb() requires that the  file tt(icmconf) is available in the directory where
program maintenance is requested.

Icb() assumes that your sources exist in and below the current working
directory. The file tt(icmconf) in bf(icmake)(1)'s distribution provides an
example of an tt(icmconf) file that can be used by icb(). In that example
tt(icmconf) file it is assumed that bf(C++) sources are maintained, but
program maintenance for, e.g., bf(C) sources can easily be configured.

Icb()() compiles all sources in each of the subdirectories named in the file
tt(CLASSES), and then compiles all sources in the current working directory.

The compiled sources result in object modules which may be kept in a
library, against which the main-object module is linked. It is also possible
to specify additional libraries against which the program must be linked.

If a library is constructed it is kept up to date by icb(). When a source is
successfully compiled its new object module replaces the old one that is found
in the library. At that point the object files are no longer required and are
removed by icb().

manpagesection(KICK-STARTING ICMBUILD)

To use icb() do as follows:
    itemization(
    it()  Install icb() in your path;
    it() copy tt(icmconf) (and probably the file tt(CLASSES)) to your
       project's base directory (i.e., the directory in which and where below
       the project's sources are found);
    it() Modify the tt(#defines) in the file tt(icmconf) to taste;
    it() Enter the names of subdirectories containing sources on separate
       lines in the file tt(CLASSES)

       Note that the order of the classes mentioned in tt(CLASSES) em(is)
       relevant.  New class (subdirectory) names can always be added, but
       reordering the lines in the tt(CLASSES) file should be avoided. If
       reordering is necessary, then first run the command tt(icmbuild clean)
       to remove all files thus far created by icb(). Recompilation is
       necessary as the names of the object files contain class order-numbers
       for identification.  These class-order numbers prevent file-name
       collisions (e.g., two classes might use a file tt(data.cc)) and thus
       replacement of a file tt(x.o) from class tt(A) by file tt(x.o) from
       class tt(B) is prevented;
    it() Now (after configuring tt(icmconf)) simply run 
        verb(
            icmbuild -h
        )
       from the project's base directory and let the help-info tell you
       what your options are. See the next section for the modes of operation.
    )

manpageoptions()

    Icb() recognizes two options, at most one should be specified:
    itemization(
    itt(-h): Provide a short usage overview.
    itt(-c): Clear the screen (using tt(tput clear)) before starting the
       compilation process
    )

    Following the optional tt(-c)  icb()() the following arguments may be
       passed to icb():
    itemization(
    itt(clean)nl()
        clean up remnants of previous activities
    itt(library)nl()
        build the library (static and optionally the dynamic library)
    itt(program)nl()
        build the binary program
    itt(program strip)nl()
        build the stripped binary program
    itt(install program path)
        install the constructed program in the specified path (to be used
       after issuing icb() tt(program))
    itt(install static path) 
       install the constructed static library in the specified path (to be
        used after issuing icb() tt(library))
    itt(install shared path) 
       install the constructed shared library in the specified path (to be
        used after issuing icb() tt(library))
    )
    After adding a line to tt(icmconf) containing
        verb(
    #define DEFCOM "program"
        )
    icb() by default uses the argument tt(program). After adding 
        verb(
    #define DEFCOM "strip"
        )
    icb() by default uses the argument tt(strip). After adding 
        verb(
    #define DEFCOM "library"
        )
    icb() by default uses the argument tt(library).

    tt(DEFCOM) is ignored when an explicit operational mode is passed to
        icb().

manpagesection(ICM-DEP)

    Class dependencies are handled by tt(icmake)'s support program
tt(icm-dep). It can be called from tt(icmake) by passing it the option
tt(-d). All options and arguments following tt(-d) are forwared to
tt(icm-dep).

    The program tt(icm-dep) is automatically called by tt(icmbuild) to handle
class dependencies. Consider two classes tt(Options) and tt(Process). If
tt(Process) uses tt(Options) and if precompiled header files are used, then in
addition to tt(Option's) header file, tt(Process's) header must also be
precompiled if tt(Option's) header file changes. Likewise, if tt(Option's)
data organization is changed and tt(Option) defines inline members used by
tt(Process) or tt(Process) defines an tt(Option) data member then, in addition
to tt(Option's) sources sources tt(Process's) sources must also be
compiled. For the latter case tt(icmconf) uses the tt(USE_ALL) specification:
if a tt(`USE_ALL') file exists in a directory, then all sources of that
directory are recompiled. 

    The program tt(icm_dep) determines all such class dependencies, and will
recompile class header files of all classes depending on classes whose header
files must be recompiled. Furthermore, if a tt(`USE_ALL') file exists in a
directory then all sources of classes depending on that directory's class are
also recompiled. 

tt(Icm-dep) recognizes various options:
    itemization(
    it() By default, it inspects dependencies of the classes mentioned in the
tt(CLASSES) file (including tt(parser) and tt(scanner) classes, if used). 
Option tt(--classes filename) (or tt(-c filename)) can be provided to specify
an alternate file.
    it() By default the contents of an tt(icmconf) file is inspected, looking
for tt(USE_ALL) and tt(PRECOMP) specifications. The option tt(--icmconf file)
(or tt(-i file)) option can be provided to specify an alternate file.
    it() The tt(icmconf) file uses the tt(#define IH) parameter to specify the
suffix of class header files that should be precompiled, their filenames being
equal to the names of the classes mentioned in the tt(CLASSES)
file. tt(CLASSES) does not specify a top-level directory. The name of the
top-level header file to precompile can be specified using the option
tt(--mainih filename) (or tt(-m filename)) specification. By default this is
tt(main.ih). 
    it() By default precompiled header files are inspected if tt(icmconf)
contains a tt(#define PRECOMP) specification. If it does not, but precompiled
headers should nonetheless be inspected, the option tt(--gch) can be
specified. Conversely, if precompiled headers should em(not) be inspected, the
option tt(--no-gch) can be specified.
    it() By default files named at the tt(#define USE_ALL) specification are
inspected if tt(icmconf) contains such a specification. If it
does not, but tt(`USE_ALL') files  should nonetheless be inspected, the option
tt(--use-all file) can be specified. Conversely, if such files should em(not)
be inspected, the option tt(--no-use-all) can be specified.
    it() Options tt(--verbose) (or tt(-V)) can be specified to increase
tt(icm_dep's) verbosity. If none is specified, tt(icm_dep) silently performs
its duties. If specified once, then tt(icm_dep) reports to the standard output
what actions it performs; if specified twice it reports the options it
encountered; if specified three times it also reports the class
dependencies; if specified more often it reports what files it encountered and
what situations caused it to make its decisions.
    it() Option tt(--version) (or tt(-v)) ends tt(icm_dep) after reporting its
version number to the standard output.
    it() Option tt(--help) (or tt(-h)) ends tt(icm_dep) after writing a
summary of its usage to the standard output.
    )
    To start its work, tt(icm_dep) needs one command-line argument:
tt(go). Any other argument results in tt(icm_dep) performing a `dry run': it
will perform all its duties (and verbose messages are displayed as if tt(go)
had been specified), but no files (precompiled headers or tt(USE_ALL) files)
will be touched or removed. If neither options nor arguments are specified
tt(icm_dep) writes its usage summary to the standard output.

    By default tt(icmbuild) calls tt(icmake -d -V go): tt(icm_dep) is called to
perform its duties and to show its actions on the standard output stream. By
specifying a tt(#define ICM_DEP) parameter in the tt(icmconf) file this
default can be overruled (cf. bf(icmconf)(7)).

manpagefiles()

    The mentioned paths are sugestive only and may be installation dependent:
    itemization(
    it() bf(/usr/share/icmake/icmconf)
        Example of a icb() configuration file;
    it() bf(/usr/share/icmake/CLASSES)
        Example of a icb() tt(CLASSES) file.
    )

manpagesection(EXAMPLES)
    
    Here is an example of the configuration file tt(icmconf) for a concrete
       program, using the library tt(libbobcat1) as an additional library:

    verbinclude(../../usr/share/icmake/icmconf)

manpageseealso()
    bf(icmake)(1), bf(icmconf)(7), bf(icmstart)(1), bf(icmstart.rc)(7)

manpagebugs()
    None reported

includefile(trailer.inc)
